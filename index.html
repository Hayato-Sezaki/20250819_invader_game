<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>Space Invaders - PC/Mobile</title>
  <style>
    :root { --ui-bg: rgba(0,0,0,.35); }
    html, body { height: 100%; }
    body {
      margin: 0; background: radial-gradient(1200px 800px at 50% -200px, #16203a 0%, #0b0f19 45%, #070a12 100%);
      color: #fff; font-family: system-ui, -apple-system, Segoe UI, Roboto, Noto Sans JP, sans-serif;
      overflow: hidden; touch-action: none; user-select: none;
    }
    #wrap { position: relative; width: 100vw; height: 100vh; }
    canvas { display: block; width: 100%; height: 100%; }
    /* HUD */
    .hud { position: absolute; left: 0; right: 0; top: 0; display: flex; justify-content: space-between; gap: 8px; padding: 10px 14px; font-weight: 700; letter-spacing: .02em; }
    .badge { background: var(--ui-bg); backdrop-filter: blur(6px); -webkit-backdrop-filter: blur(6px); border: 1px solid rgba(255,255,255,.08); border-radius: 12px; padding: 6px 10px; box-shadow: 0 6px 20px rgba(0,0,0,.3) inset; }
    .flex { display: flex; gap: 10px; align-items: center; }

    /* Overlays */
    .overlay { position: absolute; inset: 0; display: grid; place-items: center; background: radial-gradient(1200px 800px at 50% 20%, rgba(10,14,24,.35), rgba(7,10,18,.6));
      opacity: 1; transition: opacity .25s ease; }
    .overlay.hidden { opacity: 0; pointer-events: none; }
    .card { background: rgba(0,0,0,.5); border: 1px solid rgba(255,255,255,.08); border-radius: 18px; padding: 20px 22px; box-shadow: 0 20px 60px rgba(0,0,0,.5); text-align: center; max-width: 560px; }
    .card h1 { margin: 0 0 6px; font-size: 1.5rem; }
    .card p { margin: 8px 0; opacity: .9; }
    .btn { display: inline-block; margin-top: 12px; padding: 10px 16px; border-radius: 12px; border: 1px solid rgba(255,255,255,.15); background: linear-gradient(#2c3a6a,#1a2342); color: #fff; font-weight: 700; cursor: pointer; }
    .btn:active { transform: translateY(1px); }

    /* Mobile Controls */
    .controls { position: absolute; left: 0; right: 0; bottom: 0; display: grid; grid-template-columns: 1fr auto 1fr; align-items: end; gap: 8px; padding: 12px; pointer-events: none; }
    .pad { pointer-events: auto; display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
    .fireWrap { pointer-events: auto; }
    .ctl { background: var(--ui-bg); border: 1px solid rgba(255,255,255,.12); border-radius: 16px; padding: 16px 18px; font-size: 1.2rem; font-weight: 800; text-align: center; box-shadow: 0 10px 35px rgba(0,0,0,.35), inset 0 8px 24px rgba(255,255,255,.05); }
    .ctl:active { transform: translateY(2px); }
    .hint { position: absolute; bottom: 88px; left: 50%; transform: translateX(-50%); opacity: .75; font-size: .9rem; }

    @media (min-width: 992px) {
      .controls { display: none; }
    }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="game" aria-label="Space Invaders"></canvas>

    <div class="hud">
      <div class="flex">
        <div class="badge" id="score">SCORE: 0</div>
        <div class="badge" id="level">LEVEL: 1</div>
      </div>
      <div class="flex">
        <div class="badge" id="lives">LIVES: 3</div>
        <div class="badge" id="hiscore">HI: 0</div>
      </div>
    </div>

    <div class="overlay" id="startOverlay">
      <div class="card">
        <h1>Space Invaders</h1>
        <p>PC: ← → で移動、スペースでショット</p>
        <p>スマホ: 画面下のボタンで操作</p>
        <button class="btn" id="startBtn">ゲーム開始</button>
      </div>
    </div>

    <div class="overlay hidden" id="gameOverOverlay">
      <div class="card">
        <h1 id="goTitle">GAME OVER</h1>
        <p id="goMsg">スコア: 0</p>
        <button class="btn" id="restartBtn">リスタート</button>
      </div>
    </div>

    <!-- Mobile Controls -->
    <div class="controls" id="mobileControls">
      <div class="pad">
        <div class="ctl" id="leftBtn">◀ 左</div>
        <div class="ctl" id="rightBtn">右 ▶</div>
      </div>
      <div class="fireWrap">
        <div class="ctl" id="fireBtn">▲ SHOOT</div>
      </div>
      <div class="pad" style="visibility:hidden"></div>
      <div class="hint">長押しで連射（クールダウン有）</div>
    </div>
  </div>

  <script>
  (() => {
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');

    const scoreEl = document.getElementById('score');
    const levelEl = document.getElementById('level');
    const livesEl = document.getElementById('lives');
    const hiEl = document.getElementById('hiscore');

    const startOverlay = document.getElementById('startOverlay');
    const gameOverOverlay = document.getElementById('gameOverOverlay');
    const startBtn = document.getElementById('startBtn');
    const restartBtn = document.getElementById('restartBtn');
    const goTitle = document.getElementById('goTitle');
    const goMsg = document.getElementById('goMsg');

    const leftBtn = document.getElementById('leftBtn');
    const rightBtn = document.getElementById('rightBtn');
    const fireBtn = document.getElementById('fireBtn');

    let W = 0, H = 0, DPR = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    function resize() {
      W = Math.floor(window.innerWidth);
      H = Math.floor(window.innerHeight);
      canvas.width = Math.floor(W * DPR);
      canvas.height = Math.floor(H * DPR);
      canvas.style.width = W + 'px';
      canvas.style.height = H + 'px';
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0);
    }
    window.addEventListener('resize', resize, { passive: true });
    resize();

    // Game State
    const state = {
      running: false,
      over: false,
      level: 1,
      score: 0,
      hi: Number(localStorage.getItem('invaders_hi')||0),
      lives: 3,
      lastTime: 0,
      playerInvuln: 0,
      inputs: { left:false, right:false, fire:false },
      bullets: [], // {x,y,w,h,vy,from}
      aliens: [], // {x,y,w,h,alive}
      alienDir: 1,
      alienVelX: 30,
      alienStepY: 18,
      alienBounds: { minX:0, maxX:0, minY:0, maxY:0 },
      alienFireCooldown: 0,
    };

    // Dimensions scale (relative to screen)
    function dims() {
      const unit = Math.min(W,H)/100; // responsive unit
      return {
        playerW: Math.max(28, unit*4.2),
        playerH: Math.max(16, unit*2.2),
        playerSpeed: Math.max(150, unit*24),
        bulletW: Math.max(3, unit*0.6),
        bulletH: Math.max(10, unit*1.8),
        bulletSpeed: Math.max(280, unit*45),
        alienW: Math.max(22, unit*3.3),
        alienH: Math.max(16, unit*2.2),
        alienGapX: Math.max(10, unit*1.5),
        alienGapY: Math.max(12, unit*1.8),
        margin: Math.max(16, unit*2.5),
      };
    }

    function resetLevel(level=1) {
      state.level = level;
      state.bullets = [];
      state.alienDir = 1;
      const d = dims();

      const rows = 5, cols = 10;
      const totalW = cols * d.alienW + (cols-1)*d.alienGapX;
      const startX = (W - totalW) / 2;
      const startY = d.margin + 20;

      state.aliens = [];
      for (let r=0; r<rows; r++) {
        for (let c=0; c<cols; c++) {
          state.aliens.push({ x: startX + c*(d.alienW + d.alienGapX), y: startY + r*(d.alienH + d.alienGapY), w: d.alienW, h: d.alienH, alive: true, type: r });
        }
      }

      // Speed scales with level
      state.alienVelX = 28 + (level-1)*6;
      state.alienStepY = Math.max(14, 18 - (level-1));
      state.alienFireCooldown = 1.1 - Math.min(.7, (level-1)*.05);

      // Player
      player.x = (W - d.playerW)/2;
      player.y = H - d.margin - d.playerH;
      player.w = d.playerW; player.h = d.playerH;
      player.cooldown = 0; state.playerInvuln = 0;
    }

    const player = { x: 0, y: 0, w: 40, h: 18, cooldown: 0 };

    function startGame() {
      state.running = true; state.over = false; state.lives = 3; state.score = 0; levelEl.textContent = `LEVEL: 1`;
      resetLevel(1);
      startOverlay.classList.add('hidden');
      gameOverOverlay.classList.add('hidden');
      state.lastTime = performance.now();
      requestAnimationFrame(loop);
    }

    function gameOver(win=false) {
      state.running = false; state.over = true;
      if (state.score > state.hi) { state.hi = state.score; localStorage.setItem('invaders_hi', state.hi); }
      goTitle.textContent = win ? 'YOU WIN!' : 'GAME OVER';
      goMsg.textContent = `スコア: ${state.score} / ハイスコア: ${state.hi}`;
      gameOverOverlay.classList.remove('hidden');
    }

    function nextLevel() {
      resetLevel(state.level+1);
      levelEl.textContent = `LEVEL: ${state.level}`;
    }

    // Input Handlers (Keyboard)
    const keys = new Set();
    window.addEventListener('keydown', (e) => {
      if (["ArrowLeft","ArrowRight"," ","Space","Spacebar","Enter"].includes(e.key)) e.preventDefault();
      keys.add(e.key);
      if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') state.inputs.left = true;
      if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') state.inputs.right = true;
      if (e.key === ' ' || e.code === 'Space') state.inputs.fire = true;
      if (!state.running && (e.key === 'Enter' || e.code === 'Space')) startGame();
    });
    window.addEventListener('keyup', (e) => {
      keys.delete(e.key);
      if (e.key === 'ArrowLeft' || e.key.toLowerCase() === 'a') state.inputs.left = false;
      if (e.key === 'ArrowRight' || e.key.toLowerCase() === 'd') state.inputs.right = false;
      if (e.key === ' ' || e.code === 'Space') state.inputs.fire = false;
    });

    // Mobile Controls (pointer)
    function hold(el, on, off) {
      let pressed = false;
      const down = (ev)=>{ ev.preventDefault(); pressed = true; on(); };
      const up = (ev)=>{ ev.preventDefault(); pressed = false; off(); };
      el.addEventListener('pointerdown', down);
      window.addEventListener('pointerup', up);
      el.addEventListener('pointerleave', (e)=>{ if (pressed) { off(); pressed=false; } });
    }
    hold(leftBtn, ()=>state.inputs.left=true, ()=>state.inputs.left=false);
    hold(rightBtn, ()=>state.inputs.right=true, ()=>state.inputs.right=false);
    hold(fireBtn, ()=>state.inputs.fire=true, ()=>state.inputs.fire=false);

    startBtn.addEventListener('click', startGame);
    restartBtn.addEventListener('click', startGame);

    // Helpers
    function clamp(v, a, b){ return Math.max(a, Math.min(b, v)); }
    function rectsOverlap(a,b){ return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y; }

    function update(dt) {
      const d = dims();

      // Player move
      const dir = (state.inputs.right?1:0) - (state.inputs.left?1:0);
      player.x += dir * d.playerSpeed * dt;
      player.x = clamp(player.x, 8, W - player.w - 8);

      // Player shooting
      player.cooldown -= dt; if (player.cooldown < 0) player.cooldown = 0;
      if (state.inputs.fire && player.cooldown <= 0) {
        state.bullets.push({ x: player.x + player.w/2 - d.bulletW/2, y: player.y - d.bulletH, w: d.bulletW, h: d.bulletH, vy: -d.bulletSpeed, from: 'player' });
        player.cooldown = 0.18; // fire rate
      }

      // Aliens bounds
      let minX=Infinity, maxX=-Infinity, maxY=-Infinity;
      let aliveCount = 0;
      for (const a of state.aliens) if (a.alive) {
        aliveCount++;
        minX = Math.min(minX, a.x);
        maxX = Math.max(maxX, a.x + a.w);
        maxY = Math.max(maxY, a.y + a.h);
      }
      if (aliveCount === 0) { nextLevel(); return; }

      // Alien speed scales up as count drops
      const speedScale = 1 + (1 - aliveCount / state.aliens.length) * 1.4 + (state.level-1)*.15;
      const vx = state.alienVelX * speedScale * state.alienDir;

      // Hit wall? then step down and reverse
      const hitLeft = (minX <= 8 && state.alienDir < 0);
      const hitRight = (maxX >= W-8 && state.alienDir > 0);
      if (hitLeft || hitRight) {
        for (const a of state.aliens) if (a.alive) a.y += state.alienStepY;
        state.alienDir *= -1;
      } else {
        for (const a of state.aliens) if (a.alive) a.x += vx * dt;
      }

      // Alien fire
      state.alienFireCooldown -= dt;
      if (state.alienFireCooldown <= 0) {
        // pick random column bottom-most alive
        const cols = new Map();
        for (const a of state.aliens) if (a.alive) {
          const key = Math.round(a.x/10); // approximate column via x
          const cur = cols.get(key);
          if (!cur || a.y > cur.y) cols.set(key, a);
        }
        const arr = [...cols.values()];
        if (arr.length) {
          const shooter = arr[Math.floor(Math.random()*arr.length)];
          state.bullets.push({ x: shooter.x + shooter.w/2 - d.bulletW/2, y: shooter.y + shooter.h, w: d.bulletW, h: d.bulletH, vy: d.bulletSpeed*0.6 + (state.level-1)*22, from: 'alien' });
        }
        state.alienFireCooldown = Math.max(.25, 1.1 - (state.level-1)*.06 - (1 - aliveCount/state.aliens.length)*.6);
      }

      // Bullets update
      for (const b of state.bullets) b.y += b.vy * dt;
      state.bullets = state.bullets.filter(b => b.y + b.h >= -40 && b.y <= H+40);

      // Collisions: player bullets → aliens
      for (const b of state.bullets) if (b.from==='player') {
        for (const a of state.aliens) if (a.alive && rectsOverlap(b,a)) {
          a.alive = false; b.y = -9999; // remove
          state.score += 10 + (4-a.type)*2; // top rows worth more
          break;
        }
      }

      // Collisions: alien bullets → player
      if (state.playerInvuln > 0) state.playerInvuln -= dt;
      else {
        for (const b of state.bullets) if (b.from==='alien' && rectsOverlap(b, player)) {
          b.y = 99999; // remove
          state.lives -= 1; state.playerInvuln = 1.0;
          if (state.lives <= 0) { gameOver(false); return; }
          break;
        }
      }

      // If aliens reach player line => game over
      if (maxY >= player.y - 6) { gameOver(false); return; }

      // HUD
      scoreEl.textContent = `SCORE: ${state.score}`;
      livesEl.textContent = `LIVES: ${state.lives}`;
      hiEl.textContent = `HI: ${Math.max(state.hi, state.score)}`;
    }

    function draw() {
      ctx.clearRect(0,0,W,H);

      // Starfield backdrop
      drawStars();

      // Player
      const p = player;
      drawPlayer(p);

      // Aliens
      for (const a of state.aliens) if (a.alive) drawAlien(a);

      // Bullets
      for (const b of state.bullets) drawBullet(b);

      // Player hit flash
      if (state.playerInvuln > 0) {
        ctx.save(); ctx.globalAlpha = 0.25 + 0.25*Math.sin(performance.now()/50); ctx.fillStyle = '#f55'; ctx.fillRect(0,0,W,H); ctx.restore();
      }
    }

    // Simple starfield
    const stars = Array.from({length: 120}, () => ({ x: Math.random(), y: Math.random(), s: Math.random()*2+0.2 }));
    function drawStars(){
      ctx.save();
      ctx.globalAlpha = .8;
      for (const st of stars) {
        const x = st.x * W; const y = (st.y * H + (performance.now()/60 * st.s) % H);
        ctx.fillStyle = 'rgba(255,255,255,.75)';
        ctx.fillRect(x, y%H, st.s, st.s);
      }
      ctx.restore();
    }

    function drawPlayer(p){
      ctx.save();
      ctx.translate(p.x + p.w/2, p.y + p.h/2);
      // body
      ctx.fillStyle = '#7ee3ff';
      roundRect(ctx, -p.w/2, -p.h/2, p.w, p.h, 4, true);
      // cannon
      ctx.fillStyle = '#d4f3ff';
      roundRect(ctx, -4, -p.h/2-8, 8, 10, 2, true);
      ctx.restore();
    }

    function drawAlien(a){
      ctx.save();
      ctx.translate(a.x + a.w/2, a.y + a.h/2);
      // different row tints
      const palette = ['#ff7aa2','#ffa552','#f3ff7e','#7effa1','#7ec8ff'];
      ctx.fillStyle = palette[a.type % palette.length];
      // main body
      roundRect(ctx, -a.w/2, -a.h/2, a.w, a.h, 3, true);
      // eyes
      ctx.fillStyle = '#0b0f19';
      ctx.fillRect(-a.w*0.22, -a.h*0.15, 4, 4);
      ctx.fillRect(a.w*0.18, -a.h*0.15, 4, 4);
      ctx.restore();
    }

    function drawBullet(b){
      ctx.save();
      ctx.fillStyle = (b.from==='player') ? '#e5f7ff' : '#ffd3a0';
      roundRect(ctx, b.x, b.y, b.w, b.h, 2, true);
      ctx.restore();
    }

    function roundRect(ctx,x,y,w,h,r,fill=true){
      const rr = Math.min(r, w/2, h/2);
      ctx.beginPath();
      ctx.moveTo(x+rr, y);
      ctx.arcTo(x+w, y, x+w, y+h, rr);
      ctx.arcTo(x+w, y+h, x, y+h, rr);
      ctx.arcTo(x, y+h, x, y, rr);
      ctx.arcTo(x, y, x+w, y, rr);
      if (fill) ctx.fill(); else ctx.stroke();
    }

    function loop(t){
      if (!state.running) return;
      const dt = Math.min(0.033, (t - state.lastTime)/1000 || 0);
      state.lastTime = t;
      update(dt);
      draw();
      requestAnimationFrame(loop);
    }

    // Start screen interaction for quick start on tap/space
    canvas.addEventListener('pointerdown', () => { if (!state.running) startGame(); });
    document.addEventListener('visibilitychange', () => {
      // pause on hide (keep state)
      if (document.hidden) state.running = false; else if (!state.over) { state.running = true; state.lastTime = performance.now(); requestAnimationFrame(loop); }
    });

    // Initialize HUD
    hiEl.textContent = `HI: ${state.hi}`;
  })();
  </script>
</body>
</html>
